{"path": "output/hf-eval-data-v3-valid/f00189_classify_image.py", "content": "# function_import --------------------\n\nfrom urllib.request import urlopen\nfrom PIL import Image\nimport torch\nimport timm\n\n# function_code --------------------\n\ndef classify_image(img_url):\n    \"\"\"\n    Classify an image from a URL into a thousand categories.\n\n    Args:\n        img_url (str): The URL of the image to be classified.\n\n    Returns:\n        torch.Tensor: The output of the model containing the probabilities for each of the 1,000 categories.\n    \"\"\"\n    img = Image.open(urlopen(img_url))\n    model = timm.create_model('convnext_base.fb_in1k', pretrained=True)\n    model = model.eval()\n    data_config = timm.data.resolve_model_data_config(model)\n    transforms = timm.data.create_transform(**data_config, is_training=False)\n    output = model(transforms(img).unsqueeze(0))\n    return output\n\n# test_function_code --------------------\n\ndef test_classify_image():\n    \"\"\"\n    Test the classify_image function.\n    \"\"\"\n    img_url = 'https://placekitten.com/200/300'\n    output = classify_image(img_url)\n    assert isinstance(output, torch.Tensor), 'Output should be a torch.Tensor'\n    assert output.size(0) == 1, 'Output tensor should have size 1 in the first dimension'\n    assert output.size(1) == 1000, 'Output tensor should have size 1000 in the second dimension'\n    return 'All Tests Passed'\n\n# call_test_function_code --------------------\n\ntest_classify_image()", "function_import": "# function_import --------------------\n\nfrom urllib.request import urlopen\nfrom PIL import Image\nimport torch\nimport timm\n\n", "function_code": "# function_code --------------------\n\ndef classify_image(img_url):\n    \"\"\"\n    Classify an image from a URL into a thousand categories.\n\n    Args:\n        img_url (str): The URL of the image to be classified.\n\n    Returns:\n        torch.Tensor: The output of the model containing the probabilities for each of the 1,000 categories.\n    \"\"\"\n    img = Image.open(urlopen(img_url))\n    model = timm.create_model('convnext_base.fb_in1k', pretrained=True)\n    model = model.eval()\n    data_config = timm.data.resolve_model_data_config(model)\n    transforms = timm.data.create_transform(**data_config, is_training=False)\n    output = model(transforms(img).unsqueeze(0))\n    return output\n\n", "test_function_code": "# test_function_code --------------------\n\ndef test_classify_image():\n    \"\"\"\n    Test the classify_image function.\n    \"\"\"\n    img_url = 'https://placekitten.com/200/300'\n    output = classify_image(img_url)\n    assert isinstance(output, torch.Tensor), 'Output should be a torch.Tensor'\n    assert output.size(0) == 1, 'Output tensor should have size 1 in the first dimension'\n    assert output.size(1) == 1000, 'Output tensor should have size 1000 in the second dimension'\n    return 'All Tests Passed'\n\n", "call_test_function_code": "# call_test_function_code --------------------\n\ntest_classify_image()", "instruct": "# function_import --------------------\n\nfrom urllib.request import urlopen\nfrom PIL import Image\nimport torch\nimport timm\n\n# function_code --------------------\n\ndef classify_image(img_url):\n    \"\"\"\n    Classify an image from a URL into a thousand categories.\n\n    Args:\n        img_url (str): The URL of the image to be classified.\n\n    Returns:\n        torch.Tensor: The output of the model containing the probabilities for each of the 1,000 categories.\n    \"\"\"", "answer": "\n    img = Image.open(urlopen(img_url))\n    model = timm.create_model('convnext_base.fb_in1k', pretrained=True)\n    model = model.eval()\n    data_config = timm.data.resolve_model_data_config(model)\n    transforms = timm.data.create_transform(**data_config, is_training=False)\n    output = model(transforms(img).unsqueeze(0))\n    return output\n\n", "prediction": "\n    \n    # Open image from url and convert it to a tensor\n    img = Image.open(urlopen(img_url))\n\n    # Load the model\n    model = timm.create_model(\"resnet50\", pretrained=True)\n\n    return torch.nn.functional.softmax(model(torch.cat([torch.stack([timm.transforms.ToTensor()(img)]).to('cuda')], dim=0)), dim=-1)[0].cpu().detach().numpy()"}