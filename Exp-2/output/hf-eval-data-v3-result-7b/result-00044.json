{"path": "output/hf-eval-data-v3-valid/f00188_classify_image.py", "content": "# function_import --------------------\n\nfrom transformers import AutoFeatureExtractor, RegNetForImageClassification\nimport torch\nfrom PIL import Image\nimport requests\nfrom io import BytesIO\n\n# function_code --------------------\n\ndef classify_image(image_url: str) -> str:\n    \"\"\"\n    Classify an image using the pretrained RegNetForImageClassification model.\n\n    Args:\n        image_url (str): The URL of the image to be classified.\n\n    Returns:\n        str: The predicted label of the image.\n\n    Raises:\n        OSError: If the model identifier is not found in the Hugging Face model hub.\n    \"\"\"\n    model = RegNetForImageClassification.from_pretrained('facebook/regnet-y-008')\n    feature_extractor = AutoFeatureExtractor.from_pretrained('facebook/regnet-y-008')\n\n    response = requests.get(image_url)\n    image = Image.open(BytesIO(response.content))\n\n    inputs = feature_extractor(images=image, return_tensors='pt')\n    with torch.no_grad():\n        logits = model(**inputs).logits\n    predicted_label = logits.argmax(-1).item()\n\n    return model.config.id2label[predicted_label]\n\n# test_function_code --------------------\n\ndef test_classify_image():\n    \"\"\"\n    Test the classify_image function with different test cases.\n    \"\"\"\n    test_image_url_1 = 'https://placekitten.com/200/300'\n    test_image_url_2 = 'https://placekitten.com/400/600'\n    test_image_url_3 = 'https://placekitten.com/800/1200'\n\n    assert isinstance(classify_image(test_image_url_1), str)\n    assert isinstance(classify_image(test_image_url_2), str)\n    assert isinstance(classify_image(test_image_url_3), str)\n\n    print('All Tests Passed')\n\n# call_test_function_code --------------------\n\nif __name__ == '__main__':\n    test_classify_image()", "function_import": "# function_import --------------------\n\nfrom transformers import AutoFeatureExtractor, RegNetForImageClassification\nimport torch\nfrom PIL import Image\nimport requests\nfrom io import BytesIO\n\n", "function_code": "# function_code --------------------\n\ndef classify_image(image_url: str) -> str:\n    \"\"\"\n    Classify an image using the pretrained RegNetForImageClassification model.\n\n    Args:\n        image_url (str): The URL of the image to be classified.\n\n    Returns:\n        str: The predicted label of the image.\n\n    Raises:\n        OSError: If the model identifier is not found in the Hugging Face model hub.\n    \"\"\"\n    model = RegNetForImageClassification.from_pretrained('facebook/regnet-y-008')\n    feature_extractor = AutoFeatureExtractor.from_pretrained('facebook/regnet-y-008')\n\n    response = requests.get(image_url)\n    image = Image.open(BytesIO(response.content))\n\n    inputs = feature_extractor(images=image, return_tensors='pt')\n    with torch.no_grad():\n        logits = model(**inputs).logits\n    predicted_label = logits.argmax(-1).item()\n\n    return model.config.id2label[predicted_label]\n\n", "test_function_code": "# test_function_code --------------------\n\ndef test_classify_image():\n    \"\"\"\n    Test the classify_image function with different test cases.\n    \"\"\"\n    test_image_url_1 = 'https://placekitten.com/200/300'\n    test_image_url_2 = 'https://placekitten.com/400/600'\n    test_image_url_3 = 'https://placekitten.com/800/1200'\n\n    assert isinstance(classify_image(test_image_url_1), str)\n    assert isinstance(classify_image(test_image_url_2), str)\n    assert isinstance(classify_image(test_image_url_3), str)\n\n    print('All Tests Passed')\n\n", "call_test_function_code": "# call_test_function_code --------------------\n\nif __name__ == '__main__':\n    test_classify_image()", "instruct": "# function_import --------------------\n\nfrom transformers import AutoFeatureExtractor, RegNetForImageClassification\nimport torch\nfrom PIL import Image\nimport requests\nfrom io import BytesIO\n\n# function_code --------------------\n\ndef classify_image(image_url: str) -> str:\n    \"\"\"\n    Classify an image using the pretrained RegNetForImageClassification model.\n\n    Args:\n        image_url (str): The URL of the image to be classified.\n\n    Returns:\n        str: The predicted label of the image.\n\n    Raises:\n        OSError: If the model identifier is not found in the Hugging Face model hub.\n    \"\"\"", "answer": "\n    model = RegNetForImageClassification.from_pretrained('facebook/regnet-y-008')\n    feature_extractor = AutoFeatureExtractor.from_pretrained('facebook/regnet-y-008')\n\n    response = requests.get(image_url)\n    image = Image.open(BytesIO(response.content))\n\n    inputs = feature_extractor(images=image, return_tensors='pt')\n    with torch.no_grad():\n        logits = model(**inputs).logits\n    predicted_label = logits.argmax(-1).item()\n\n    return model.config.id2label[predicted_label]\n\n", "prediction": "    \n\n    # load model from Hugging Face model hub\n    try:\n        model_id = \"datasets/justincao/regnet-y-16gf\"  # just a dummy value, we don't need the real model yet\n        model = RegNetForImageClassification.from_pretrained(model_id)\n    except OSError:\n        raise OSError('Model identifier not found in Hugging Face model hub')\n    \n    # load feature extractor from Hugging Face model hub\n    feature_extractor = AutoFeatureExtractor.from_pretrained(\"google/regnet-y-16gf\")\n\n    # preprocess image and add batch dimension using the preprocessing function\n    image = Image.open(BytesIO(requests.get(image_url).content))  # download image from URL\n    inputs = feature_extractor(images=image, return_tensors=\"pt\", normalize=True)\n    \n    # predict class label with model and get predicted probabilities using the argmax function\n    labels = [l.strip() for l in open('./labels.txt', 'r').readlines()]  # load class labels from file\n    outputs = model(**inputs)\n    logits = outputs.logits[0].cpu().detach().numpy()\n    probabilities = torch.softmax(torch.from_numpy(logits), dim=0).tolist()\n    \n    # get predicted class using argmax function (index of highest entry in probability vector)\n    predicted_class = labels[int(torch.argmax(probabilities))]\n    \n    return f'Predicted class: {predicted_class} \\n with probability: {round(max(probabilities), 4)*100}%'"}