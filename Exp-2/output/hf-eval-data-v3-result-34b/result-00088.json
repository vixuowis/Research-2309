{"path": "output/hf-eval-data-v3-valid/f00375_load_and_classify_video.py", "content": "# function_import --------------------\n\nfrom transformers import AutoModelForVideoClassification\n\n# function_code --------------------\n\ndef load_and_classify_video(model_name: str, video_path: str):\n    \"\"\"\n    Load a pre-trained model for video classification and classify a video.\n\n    Args:\n        model_name (str): The name of the pre-trained model.\n        video_path (str): The path to the video file to be classified.\n\n    Returns:\n        The classification result.\n\n    Raises:\n        FileNotFoundError: If the video file does not exist.\n    \"\"\"\n    # Load the pre-trained model\n    model = AutoModelForVideoClassification.from_pretrained(model_name)\n\n    # TODO: Add code to load the video file and classify it using the model\n    # This is a placeholder and will not actually classify the video\n    return 'classification result'\n\n# test_function_code --------------------\n\ndef test_load_and_classify_video():\n    \"\"\"\n    Test the load_and_classify_video function.\n    \"\"\"\n    # Test with a known model and video file\n    result = load_and_classify_video('lmazzon70/videomae-base-finetuned-kinetics-finetuned-rwf2000mp4-epochs8-batch8-kb', 'test_video.mp4')\n    assert isinstance(result, str), 'The result should be a string.'\n\n    # TODO: Add more test cases\n\n    return 'All Tests Passed'\n\n# call_test_function_code --------------------\n\ntest_load_and_classify_video()", "function_import": "# function_import --------------------\n\nfrom transformers import AutoModelForVideoClassification\n\n", "function_code": "# function_code --------------------\n\ndef load_and_classify_video(model_name: str, video_path: str):\n    \"\"\"\n    Load a pre-trained model for video classification and classify a video.\n\n    Args:\n        model_name (str): The name of the pre-trained model.\n        video_path (str): The path to the video file to be classified.\n\n    Returns:\n        The classification result.\n\n    Raises:\n        FileNotFoundError: If the video file does not exist.\n    \"\"\"\n    # Load the pre-trained model\n    model = AutoModelForVideoClassification.from_pretrained(model_name)\n\n    # TODO: Add code to load the video file and classify it using the model\n    # This is a placeholder and will not actually classify the video\n    return 'classification result'\n\n", "test_function_code": "# test_function_code --------------------\n\ndef test_load_and_classify_video():\n    \"\"\"\n    Test the load_and_classify_video function.\n    \"\"\"\n    # Test with a known model and video file\n    result = load_and_classify_video('lmazzon70/videomae-base-finetuned-kinetics-finetuned-rwf2000mp4-epochs8-batch8-kb', 'test_video.mp4')\n    assert isinstance(result, str), 'The result should be a string.'\n\n    # TODO: Add more test cases\n\n    return 'All Tests Passed'\n\n", "call_test_function_code": "# call_test_function_code --------------------\n\ntest_load_and_classify_video()", "instruct": "# function_import --------------------\n\nfrom transformers import AutoModelForVideoClassification\n\n# function_code --------------------\n\ndef load_and_classify_video(model_name: str, video_path: str):\n    \"\"\"\n    Load a pre-trained model for video classification and classify a video.\n\n    Args:\n        model_name (str): The name of the pre-trained model.\n        video_path (str): The path to the video file to be classified.\n\n    Returns:\n        The classification result.\n\n    Raises:\n        FileNotFoundError: If the video file does not exist.\n    \"\"\"", "answer": "\n    # Load the pre-trained model\n    model = AutoModelForVideoClassification.from_pretrained(model_name)\n\n    # TODO: Add code to load the video file and classify it using the model\n    # This is a placeholder and will not actually classify the video\n    return 'classification result'\n\n", "prediction": "\n    # load model and prepare it for evaluation \n    model = AutoModelForVideoClassification.from_pretrained(model_name)\n    model.eval()\n    \n    # check whether the file exists\n    from pathlib import Path\n    video_path = Path(video_path)\n    if not video_path.is_file():\n        raise FileNotFoundError(\"{} is not a valid video file\".format(video_path))  \n\n    # prepare input tensor for classification\n    from transformers import VideoUtils\n    from PIL import Image\n    from io import BytesIO\n    \n    # load raw video data and extract the first frame\n    video = VideoUtils.load_video(str(video_path))[0][\"video\"]\n    video_frame = Image.open(BytesIO(video)).convert(\"RGB\")\n    video_feature = VideoUtils.resize_and_center_crop(video_frame, size=112)\n    \n    # load the model's input tokenizer\n    feature_extractor = AutoFeatureExtractor.from_pretrained(model_name)\n    inputs = feature_extractor(images=[video_feature], return_tensors=\"pt\")\n\n    # classify video and extract top 5 predicted labels\n    outputs = model(**inputs)  \n    logits = outputs.logits[0]\n    _, indices = torch.topk(outputs[\"logits\"], k=5, dim=-1)\n    \n    return indices, logits\n"}