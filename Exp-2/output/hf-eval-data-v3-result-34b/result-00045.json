{"path": "output/hf-eval-data-v3-valid/f00189_classify_image.py", "content": "# function_import --------------------\n\nfrom urllib.request import urlopen\nfrom PIL import Image\nimport torch\nimport timm\n\n# function_code --------------------\n\ndef classify_image(img_url):\n    \"\"\"\n    Classify an image from a URL into a thousand categories.\n\n    Args:\n        img_url (str): The URL of the image to be classified.\n\n    Returns:\n        torch.Tensor: The output of the model containing the probabilities for each of the 1,000 categories.\n    \"\"\"\n    img = Image.open(urlopen(img_url))\n    model = timm.create_model('convnext_base.fb_in1k', pretrained=True)\n    model = model.eval()\n    data_config = timm.data.resolve_model_data_config(model)\n    transforms = timm.data.create_transform(**data_config, is_training=False)\n    output = model(transforms(img).unsqueeze(0))\n    return output\n\n# test_function_code --------------------\n\ndef test_classify_image():\n    \"\"\"\n    Test the classify_image function.\n    \"\"\"\n    img_url = 'https://placekitten.com/200/300'\n    output = classify_image(img_url)\n    assert isinstance(output, torch.Tensor), 'Output should be a torch.Tensor'\n    assert output.size(0) == 1, 'Output tensor should have size 1 in the first dimension'\n    assert output.size(1) == 1000, 'Output tensor should have size 1000 in the second dimension'\n    return 'All Tests Passed'\n\n# call_test_function_code --------------------\n\ntest_classify_image()", "function_import": "# function_import --------------------\n\nfrom urllib.request import urlopen\nfrom PIL import Image\nimport torch\nimport timm\n\n", "function_code": "# function_code --------------------\n\ndef classify_image(img_url):\n    \"\"\"\n    Classify an image from a URL into a thousand categories.\n\n    Args:\n        img_url (str): The URL of the image to be classified.\n\n    Returns:\n        torch.Tensor: The output of the model containing the probabilities for each of the 1,000 categories.\n    \"\"\"\n    img = Image.open(urlopen(img_url))\n    model = timm.create_model('convnext_base.fb_in1k', pretrained=True)\n    model = model.eval()\n    data_config = timm.data.resolve_model_data_config(model)\n    transforms = timm.data.create_transform(**data_config, is_training=False)\n    output = model(transforms(img).unsqueeze(0))\n    return output\n\n", "test_function_code": "# test_function_code --------------------\n\ndef test_classify_image():\n    \"\"\"\n    Test the classify_image function.\n    \"\"\"\n    img_url = 'https://placekitten.com/200/300'\n    output = classify_image(img_url)\n    assert isinstance(output, torch.Tensor), 'Output should be a torch.Tensor'\n    assert output.size(0) == 1, 'Output tensor should have size 1 in the first dimension'\n    assert output.size(1) == 1000, 'Output tensor should have size 1000 in the second dimension'\n    return 'All Tests Passed'\n\n", "call_test_function_code": "# call_test_function_code --------------------\n\ntest_classify_image()", "instruct": "# function_import --------------------\n\nfrom urllib.request import urlopen\nfrom PIL import Image\nimport torch\nimport timm\n\n# function_code --------------------\n\ndef classify_image(img_url):\n    \"\"\"\n    Classify an image from a URL into a thousand categories.\n\n    Args:\n        img_url (str): The URL of the image to be classified.\n\n    Returns:\n        torch.Tensor: The output of the model containing the probabilities for each of the 1,000 categories.\n    \"\"\"", "answer": "\n    img = Image.open(urlopen(img_url))\n    model = timm.create_model('convnext_base.fb_in1k', pretrained=True)\n    model = model.eval()\n    data_config = timm.data.resolve_model_data_config(model)\n    transforms = timm.data.create_transform(**data_config, is_training=False)\n    output = model(transforms(img).unsqueeze(0))\n    return output\n\n", "prediction": "\n    \n    # download the image from the given URL and load it into a PIL Image object\n    with urlopen(img_url) as stream:\n        img = Image.open(stream)\n        \n    # preprocess the image for the model\n    model = timm.create_model(\"efficientnet_b0\", pretrained=True).eval()\n    inputs = torch.cat([model.preprocess_image(img)]).unsqueeze(0)\n    \n    # classify the image and return the model outputs\n    with torch.no_grad():\n        outputs = model(inputs)\n    return outputs"}