{'code': "###Instruction: Develop a pipeline that detects objects present in an image using computer vision.\n###Output: <<<domain>>>: Computer Vision Object Detection\n<<<api_call>>>: YolosForObjectDetection.from_pretrained('hustvl/yolos-tiny')\n<<<api_provider>>>: Hugging Face Transformers\n<<<explanation>>>: 1. Begin by importing the necessary libraries, including YolosFeatureExtractor and YolosForObjectDetection from the transformers library, Image from PIL, and requests for loading an image.\n2. Load the pretrained YOLOS Tiny model using Hugging Face transformers library by calling YolosForObjectDetection.from_pretrained('hustvl/yolos-tiny').\n3. Utilize the YolosFeatureExtractor.from_pretrained('hustvl/yolos-tiny') method to prepare the model's feature extractor.\n4. Obtain an image for object detection using the Image.open method from PIL and requests.get to fetch the image from the specified URL.\n5. Call the feature extractor's 'images' method, passing the input image and setting 'return_tensors' to 'pt'.\n6. Pass the processed input tensors to the pretrained YOLOS model to obtain object detection outputs, including logits and predicted bounding boxes for the identified objects.\n<<<code>>>: from transformers import YolosFeatureExtractor, YolosForObjectDetection\nfrom PIL import Image\nimport requests\n\nurl = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nimage = Image.open(requests.get(url, stream=True).raw)\n\nfeature_extractor = YolosFeatureExtractor.from_pretrained('hustvl/yolos-tiny')\nmodel = YolosForObjectDetection.from_pretrained('hustvl/yolos-tiny')\n\ninputs = feature_extractor(images=image, return_tensors='pt')\noutputs = model(**inputs)\nlogits = outputs.logits\nbboxes = outputs.pred_boxes", 'api_call': "YolosForObjectDetection.from_pretrained('hustvl/yolos-tiny')", 'provider': 'Hugging Face Transformers', 'api_data': {'domain': 'Computer Vision Object Detection', 'framework': 'Hugging Face Transformers', 'functionality': 'Object Detection', 'api_name': 'hustvl/yolos-tiny', 'api_call': "YolosForObjectDetection.from_pretrained('hustvl/yolos-tiny')", 'api_arguments': {'images': 'image', 'return_tensors': 'pt'}, 'python_environment_requirements': ['transformers', 'PIL', 'requests'], 'example_code': "from transformers import YolosFeatureExtractor, YolosForObjectDetection\nfrom PIL import Image\nimport requests\nurl = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nimage = Image.open(requests.get(url, stream=True).raw)\nfeature_extractor = YolosFeatureExtractor.from_pretrained('hustvl/yolos-tiny')\nmodel = YolosForObjectDetection.from_pretrained('hustvl/yolos-tiny')\ninputs = feature_extractor(images=image, return_tensors=pt)\noutputs = model(**inputs)\nlogits = outputs.logits\nbboxes = outputs.pred_boxes", 'performance': {'dataset': 'COCO 2017 validation', 'accuracy': '28.7 AP'}, 'description': 'YOLOS is a Vision Transformer (ViT) trained using the DETR loss. Despite its simplicity, a base-sized YOLOS model is able to achieve 42 AP on COCO validation 2017 (similar to DETR and more complex frameworks such as Faster R-CNN). The model is trained using a bipartite matching loss: one compares the predicted classes + bounding boxes of each of the N = 100 object queries to the ground truth annotations, padded up to the same length N (so if an image only contains 4 objects, 96 annotations will just have a no object as class and no bounding box as bounding box). The Hungarian matching algorithm is used to create an optimal one-to-one mapping between each of the N queries and each of the N annotations. Next, standard cross-entropy (for the classes) and a linear combination of the L1 and generalized IoU loss (for the bounding boxes) are used to optimize the parameters of the model.'}}


/root/miniconda3/envs/py38/lib/python3.8/site-packages/transformers/models/yolos/feature_extraction_yolos.py:28: FutureWarning: The class YolosFeatureExtractor is deprecated and will be removed in version 5 of Transformers. Please use YolosImageProcessor instead.
  warnings.warn(
The `max_size` parameter is deprecated and will be removed in v4.26. Please specify in `size['longest_edge'] instead`.


