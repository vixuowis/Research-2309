{'code': "###Instruction: We are building a video analysis tool that can automatically detect the main action happening in a given video clip.\n###Output: <<<domain>>>: Computer Vision Video Classification\n<<<api_call>>>: VideoMAEForVideoClassification.from_pretrained('nateraw/videomae-base-finetuned-ucf101')\n<<<api_provider>>>: Hugging Face Transformers\n<<<explanation>>>: 1. Import the required libraries, including decord for handling video files and transformers for the VideoMAE feature extractor and model.\n2. Download the video clip using the Hugging Face Hub library.\n3. Load the video using the decord.VideoReader and sample frames from the video given certain parameters like clip length, frame sample rate, etc.\n4. Initialize the VideoMAE feature extractor and model with the pretrained 'nateraw/videomae-base-finetuned-ucf101' model.\n5. Extract features from the frames using the feature extractor and perform inference using the VideoMAE model.\n6. Obtain the predicted label (main action) as the argmax value of the output logits.\n<<<code>>>: from decord import VideoReader, cpu\nimport torch\nimport numpy as np\nfrom transformers import VideoMAEFeatureExtractor, VideoMAEForVideoClassification\nfrom huggingface_hub import hf_hub_download\n\ndef sample_frame_indices(clip_len, frame_sample_rate, seg_len):\n    converted_len = int(clip_len * frame_sample_rate)\n    end_idx = np.random.randint(converted_len, seg_len)\n    start_idx = end_idx - converted_len\n    indices = np.linspace(start_idx, end_idx, num=clip_len)\n    indices = np.clip(indices, start_idx, end_idx - 1).astype(np.int64)\n    return indices\n\nfile_path = hf_hub_download('archery.mp4')\nvideoreader = VideoReader(file_path, num_threads=1, ctx=cpu(0))\nindices = sample_frame_indices(clip_len=16, frame_sample_rate=4, seg_len=len(videoreader))\nvideo = videoreader.get_batch(indices).asnumpy()\n\nfeature_extractor = VideoMAEFeatureExtractor.from_pretrained('nateraw/videomae-base-finetuned-ucf101')\nmodel = VideoMAEForVideoClassification.from_pretrained('nateraw/videomae-base-finetuned-ucf101')\n\ninputs = feature_extractor(list(video), return_tensors='pt')\nwith torch.no_grad():\n    outputs = model(**inputs)\n    logits = outputs.logits\n\npredicted_label = logits.argmax(-1).item()\nprint(model.config.id2label[predicted_label])\n", 'api_call': "VideoMAEForVideoClassification.from_pretrained('nateraw/videomae-base-finetuned-ucf101')", 'provider': 'Hugging Face Transformers', 'api_data': {'domain': 'Computer Vision Video Classification', 'framework': 'Hugging Face Transformers', 'functionality': 'Video Action Recognition', 'api_name': 'videomae-base-finetuned-ucf101', 'api_call': "VideoMAEForVideoClassification.from_pretrained('nateraw/videomae-base-finetuned-ucf101')", 'api_arguments': {'pretrained_model_name_or_path': 'nateraw/videomae-base-finetuned-ucf101'}, 'python_environment_requirements': ['transformers', 'decord', 'huggingface_hub'], 'example_code': 'from decord import VideoReader, cpu\nimport torch\nimport numpy as np\nfrom transformers import VideoMAEFeatureExtractor, VideoMAEForVideoClassification\nfrom huggingface_hub import hf_hub_download\nnp.random.seed(0)\ndef sample_frame_indices(clip_len, frame_sample_rate, seg_len):\n converted_len = int(clip_len * frame_sample_rate)\n end_idx = np.random.randint(converted_len, seg_len)\n start_idx = end_idx - converted_len\n indices = np.linspace(start_idx, end_idx, num=clip_len)\n indices = np.clip(indices, start_idx, end_idx - 1).astype(np.int64)\n return indices\nfile_path = hf_hub_download(\n repo_id=nateraw/dino-clips, filename=archery.mp4, repo_type=space\n)\nvideoreader = VideoReader(file_path, num_threads=1, ctx=cpu(0))\nvideoreader.seek(0)\nindices = sample_frame_indices(clip_len=16, frame_sample_rate=4, seg_len=len(videoreader))\nvideo = videoreader.get_batch(indices).asnumpy()\nfeature_extractor = VideoMAEFeatureExtractor.from_pretrained(nateraw/videomae-base-finetuned-ucf101)\nmodel = VideoMAEForVideoClassification.from_pretrained(nateraw/videomae-base-finetuned-ucf101)\ninputs = feature_extractor(list(video), return_tensors=pt)\nwith torch.no_grad():\n outputs = model(**inputs)\n logits = outputs.logits\npredicted_label = logits.argmax(-1).item()\nprint(model.config.id2label[predicted_label])', 'performance': {'dataset': 'UCF101', 'accuracy': 0.758209764957428}, 'description': 'VideoMAE Base model fine tuned on UCF101 for Video Action Recognition'}}

Traceback (most recent call last):
  File "output/hf-eval-data-v2/f00762_video_action_recognition.py", line 3, in <module>
    from decord import VideoReader, cpu
ModuleNotFoundError: No module named 'decord'
